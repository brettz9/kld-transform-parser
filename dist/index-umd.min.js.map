{"version":3,"file":"index-umd.min.js","sources":["../lib/TransformLexeme.js","../lib/TransformLexer.js","../lib/TransformParser.js","../lib/SampleHandler.js"],"sourcesContent":["/**\n *  TransformLexeme.js\n *\n *  @copyright 2005,2013 Kevin Lindsey\n */\n\n/*\n *  token type enumerations\n */\nTransformLexeme.UNDEFINED = 0;\nTransformLexeme.MATRIX = 1;\nTransformLexeme.TRANSLATE = 2;\nTransformLexeme.SCALE = 3;\nTransformLexeme.ROTATE = 4;\nTransformLexeme.SKEWX = 5;\nTransformLexeme.SKEWY = 6;\nTransformLexeme.LPAREN = 7;\nTransformLexeme.RPAREN = 8;\nTransformLexeme.NUMBER = 9;\nTransformLexeme.EOD = 10;\n\n/**\n *  TransformLexeme\n *\n *  @class\n *  @param {Object} type\n *  @param {Object} text\n */\nfunction TransformLexeme(type, text) {\n    this.init(type, text);\n}\n\n/**\n *  init\n *\n *  @param {number} type\n *  @param {string} text\n */\nTransformLexeme.prototype.init = function(type, text) {\n    this.type = type;\n    this.text = text;\n};\n\n/**\n *  typeis\n *\n *  @param {number} type\n *  @returns {boolean} Returns true if this token matches the specified type\n */\nTransformLexeme.prototype.typeis = function(type) {\n    return this.type === type;\n};\n\nexport default TransformLexeme;\n","/**\n *  TransformLexer.js\n *\n *  @copyright 2005, 2013 Kevin Lindsey\n */\n\nimport TransformLexeme from \"./TransformLexeme.js\";\n\n\n/**\n *  TransformLexer\n *\n *  @class\n *  @param {string} transformText\n */\nfunction TransformLexer(transformText) {\n    if (transformText === null || transformText === undefined) {\n        transformText = \"\";\n    }\n\n    this.setTransformText(transformText);\n}\n\n/**\n *  setTransformText\n *\n *  @param {string} transformText\n */\nTransformLexer.prototype.setTransformText = function(transformText) {\n    if (typeof transformText !== \"string\") {\n        throw new Error(\"TransformLexer.setTransformText: The first parameter must be a string\");\n    }\n\n    this._transformText = transformText;\n};\n\n/**\n *  getNextToken\n */\nTransformLexer.prototype.getNextToken = function() {\n    let result = null;\n    let buffer = this._transformText;\n\n    while (result === null) {\n        if (buffer === null || buffer === \"\") {\n            result = new TransformLexeme(TransformLexeme.EOD, \"\");\n        }\n        else if (buffer.match(/^([ \\t\\r\\n,]+)/)) {\n            buffer = buffer.substr(RegExp.$1.length);\n        }\n        else if (buffer.match(/^(matrix)\\b/)) {\n            result = new TransformLexeme(TransformLexeme.MATRIX, RegExp.$1);\n            buffer = buffer.substr(RegExp.$1.length);\n        }\n        else if (buffer.match(/^(translate)\\b/)) {\n            result = new TransformLexeme(TransformLexeme.TRANSLATE, RegExp.$1);\n            buffer = buffer.substr(RegExp.$1.length);\n        }\n        else if (buffer.match(/^(scale)\\b/)) {\n            result = new TransformLexeme(TransformLexeme.SCALE, RegExp.$1);\n            buffer = buffer.substr(RegExp.$1.length);\n        }\n        else if (buffer.match(/^(rotate)\\b/)) {\n            result = new TransformLexeme(TransformLexeme.ROTATE, RegExp.$1);\n            buffer = buffer.substr(RegExp.$1.length);\n        }\n        else if (buffer.match(/^(skewX)\\b/)) {\n            result = new TransformLexeme(TransformLexeme.SKEWX, RegExp.$1);\n            buffer = buffer.substr(RegExp.$1.length);\n        }\n        else if (buffer.match(/^(skewY)\\b/)) {\n            result = new TransformLexeme(TransformLexeme.SKEWY, RegExp.$1);\n            buffer = buffer.substr(RegExp.$1.length);\n        }\n        else if (buffer.match(/^(\\()/)) {\n            result = new TransformLexeme(TransformLexeme.LPAREN, RegExp.$1);\n            buffer = buffer.substr(RegExp.$1.length);\n        }\n        else if (buffer.match(/^(\\))/)) {\n            result = new TransformLexeme(TransformLexeme.RPAREN, RegExp.$1);\n            buffer = buffer.substr(RegExp.$1.length);\n        }\n        /* eslint-disable-next-line unicorn/no-unsafe-regex */\n        else if (buffer.match(/^(([-+]?\\d+(\\.\\d*)?|[-+]?\\.\\d+)([eE][-+]?\\d+)?)/)) {\n            result = new TransformLexeme(TransformLexeme.NUMBER, parseFloat(RegExp.$1));\n            buffer = buffer.substr(RegExp.$1.length);\n        }\n        else {\n            throw new Error(\"TransformLexer.getNextToken: unable to tokenize text: \" + buffer);\n        }\n    }\n\n    this._transformText = buffer;\n\n    return result;\n};\n\nexport default TransformLexer;\n","/**\n *  TransformParser.js\n *\n *  @copyright 2005, 2013 Kevin Lindsey\n */\n\nimport TransformLexer from \"./TransformLexer.js\";\nimport TransformLexeme from \"./TransformLexeme.js\";\n\n/*\n *  class constants\n */\nTransformParser.PARAMCOUNT = {\n    matrix: [6],\n    translate: [1, 2],\n    scale: [1, 2],\n    rotate: [1, 3],\n    skewX: [1],\n    skewY: [1]\n};\nTransformParser.METHODNAME = {\n    matrix: \"matrix\",\n    translate: \"translate\",\n    scale: \"scale\",\n    rotate: \"rotate\",\n    skewX: \"skewX\",\n    skewY: \"skewY\"\n};\n\n/**\n *  TransformParser\n *\n *  @class\n */\nfunction TransformParser() {\n    this._lexer = new TransformLexer();\n    this._handler = null;\n}\n\n/**\n *  parseTransform\n *\n *  @param {string} transformText\n */\nTransformParser.prototype.parseTransform = function(transformText) {\n    if (typeof transformText !== \"string\") {\n        throw new Error(\"TransformParser.parseTransform: The first parameter must be a string\");\n    }\n\n    // init handler\n    if (this._handler !== null && typeof this._handler.beginParse === \"function\") {\n        this._handler.beginParse();\n    }\n\n    // pass the transformText to the lexer\n    const lexer = this._lexer;\n\n    lexer.setTransformText(transformText);\n\n    // Process all tokens\n    let token = lexer.getNextToken();\n\n    while (token.typeis(TransformLexeme.EOD) === false) {\n        let command;\n        let paramCounts;\n        const params = [];\n\n        // process current token\n        switch (token.type) {\n            case TransformLexeme.MATRIX:\n            case TransformLexeme.TRANSLATE:\n            case TransformLexeme.SCALE:\n            case TransformLexeme.ROTATE:\n            case TransformLexeme.SKEWX:\n            case TransformLexeme.SKEWY:\n                command = token.text;\n                paramCounts = TransformParser.PARAMCOUNT[command];\n\n                // Advance past command token\n                token = lexer.getNextToken();\n                break;\n\n            default:\n                throw new Error(\"TransformParser.parseTransform: expected transform type: \" + token.text);\n        }\n\n        // handle opening parenthesis\n        if (token.type !== TransformLexeme.LPAREN) {\n            throw new Error(\"TransformParser.parserTransform: expected opening parenthesis: \" + token.text);\n        }\n        token = lexer.getNextToken();\n\n        // Get parameters\n        while (token !== TransformLexeme.EOD && token.type === TransformLexeme.NUMBER) {\n            // convert current parameter to a float and add to\n            // parameter list\n            params.push(token.text - 0);\n\n            // advance to next token\n            token = lexer.getNextToken();\n        }\n\n        // verify parameter counts\n        let valid = false;\n        const actualCount = params.length;\n\n        for (let i = 0; i < paramCounts.length; i++) {\n            if (paramCounts[i] === actualCount) {\n                valid = true;\n                break;\n            }\n        }\n\n        if (valid === false) {\n            throw new Error(\"TransformParser.parserTransform: incorrect number of arguments for \" + command);\n        }\n\n        // handle closing parenthesis\n        if (token.type !== TransformLexeme.RPAREN) {\n            throw new Error(\"TransformParser.parserTransform: expected closing parenthesis: \" + token.text);\n        }\n        token = lexer.getNextToken();\n\n        // fire handler\n        if (this._handler !== null) {\n            const handler = this._handler;\n            const methodName = TransformParser.METHODNAME[command];\n\n            if (handler !== null && typeof handler[methodName] === \"function\") {\n                handler[methodName](...params);\n            }\n        }\n    }\n};\n\n/**\n *  setHandler\n *\n *  @param {Function} handler\n */\nTransformParser.prototype.setHandler = function(handler) {\n    this._handler = handler;\n};\n\nexport default TransformParser;\n","/* eslint-disable prefer-rest-params, no-empty-function */\n/**\n *  SampleHandler.js\n *\n *  @copyright 2005, 2013 Kevin Lindsey\n */\n\n/**\n *  SampleHandler\n *\n *  @class\n */\nfunction SampleHandler() {\n}\n\n/**\n *  show\n *\n *  @param {string} name\n *  @param {Array<string>} params\n */\nSampleHandler.prototype.show = function(name, ...params) {\n    console.log(`${name}(${params.join(\",\")})`);\n};\n\n/**\n *  matrix\n *\n *  @param {number} a\n *  @param {number} b\n *  @param {number} c\n *  @param {number} d\n *  @param {number} e\n *  @param {number} f\n */\nSampleHandler.prototype.matrix = function(a, b, c, d, e, f) {\n    this.show(\"matrix\", ...arguments);\n};\n\n/**\n *  translate\n *\n *  @param {number} tx\n *  @param {number} ty\n */\nSampleHandler.prototype.translate = function(tx, ty) {\n    this.show(\"translate\", ...arguments);\n};\n\n/**\n *  scale\n *\n *  @param {number} sx\n *  @param {number} sy\n */\nSampleHandler.prototype.scale = function(sx, sy) {\n    this.show(\"scale\", ...arguments);\n};\n\n/**\n *  rotate\n *\n *  @param {number} rotateAngle\n *  @param {number} cx\n *  @param {number} cy\n */\nSampleHandler.prototype.rotate = function(rotateAngle, cx, cy) {\n    this.show(\"rotate\", ...arguments);\n};\n\n/**\n *  skewX\n *\n *  @param {number} skewAngle\n */\nSampleHandler.prototype.skewX = function(skewAngle) {\n    this.show(\"skewX\", ...arguments);\n};\n\n/**\n *  skewY\n *\n *  @param {number} skewAngle\n */\nSampleHandler.prototype.skewY = function(skewAngle) {\n    this.show(\"skewY\", ...arguments);\n};\n\nexport default SampleHandler;\n"],"names":["TransformLexeme","type","text","init","TransformLexer","transformText","setTransformText","TransformParser","_lexer","_handler","SampleHandler","UNDEFINED","MATRIX","TRANSLATE","SCALE","ROTATE","SKEWX","SKEWY","LPAREN","RPAREN","NUMBER","EOD","prototype","typeis","this","Error","_transformText","getNextToken","result","buffer","match","substr","RegExp","$1","length","parseFloat","PARAMCOUNT","matrix","translate","scale","rotate","skewX","skewY","METHODNAME","parseTransform","beginParse","lexer","token","command","paramCounts","params","push","valid","actualCount","i","handler","methodName","setHandler","show","name","console","log","join","a","b","c","d","e","f","arguments","tx","ty","sx","sy","rotateAngle","cx","cy","skewAngle"],"mappings":"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"}