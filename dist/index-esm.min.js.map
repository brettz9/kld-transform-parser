{"version":3,"file":"index-esm.min.js","sources":["../lib/TransformLexeme.js","../lib/TransformLexer.js","../lib/TransformParser.js","../lib/SampleHandler.js"],"sourcesContent":["/**\n *  TransformLexeme.js\n *\n *  @copyright 2005,2013 Kevin Lindsey\n */\n\n/**\n *  TransformLexeme\n *\n *  @param {Object} type\n *  @param {Object} text\n */\nclass TransformLexeme {\n    constructor(type, text) {\n        this.type = type;\n        this.text = text;\n    }\n\n    typeis(type) {\n        return this.type === type;\n    }\n}\n\n/*\n *  token type enumerations\n */\nTransformLexeme.UNDEFINED = 0;\nTransformLexeme.MATRIX = 1;\nTransformLexeme.TRANSLATE = 2;\nTransformLexeme.SCALE = 3;\nTransformLexeme.ROTATE = 4;\nTransformLexeme.SKEWX = 5;\nTransformLexeme.SKEWY = 6;\nTransformLexeme.LPAREN = 7;\nTransformLexeme.RPAREN = 8;\nTransformLexeme.NUMBER = 9;\nTransformLexeme.EOD = 10;\n\nexport default TransformLexeme;\n","/**\n *  TransformLexer.js\n *\n *  @copyright 2005, 2013 Kevin Lindsey\n */\n\nimport TransformLexeme from \"./TransformLexeme.js\";\n\n\n/**\n *  TransformLexer\n *\n *  @param {string} transformText\n */\nclass TransformLexer {\n    constructor(transformText) {\n        if (transformText === null || transformText === undefined) {\n            transformText = \"\";\n        }\n\n        this.setTransformText(transformText);\n    }\n\n    /**\n     *  setTransformText\n     *\n     *  @param {string} transformText\n     */\n    setTransformText(transformText) {\n        if (typeof transformText !== \"string\") {\n            throw new Error(\"TransformLexer.setTransformText: The first parameter must be a string\");\n        }\n\n        this._transformText = transformText;\n    }\n\n    /**\n     *  getNextToken\n     */\n    getNextToken() {\n        let result = null;\n        let buffer = this._transformText;\n\n        while (result === null) {\n            if (buffer === null || buffer === \"\") {\n                result = new TransformLexeme(TransformLexeme.EOD, \"\");\n            }\n            else if (buffer.match(/^([ \\t\\r\\n,]+)/)) {\n                buffer = buffer.substr(RegExp.$1.length);\n            }\n            else if (buffer.match(/^(matrix)\\b/)) {\n                result = new TransformLexeme(TransformLexeme.MATRIX, RegExp.$1);\n                buffer = buffer.substr(RegExp.$1.length);\n            }\n            else if (buffer.match(/^(translate)\\b/)) {\n                result = new TransformLexeme(TransformLexeme.TRANSLATE, RegExp.$1);\n                buffer = buffer.substr(RegExp.$1.length);\n            }\n            else if (buffer.match(/^(scale)\\b/)) {\n                result = new TransformLexeme(TransformLexeme.SCALE, RegExp.$1);\n                buffer = buffer.substr(RegExp.$1.length);\n            }\n            else if (buffer.match(/^(rotate)\\b/)) {\n                result = new TransformLexeme(TransformLexeme.ROTATE, RegExp.$1);\n                buffer = buffer.substr(RegExp.$1.length);\n            }\n            else if (buffer.match(/^(skewX)\\b/)) {\n                result = new TransformLexeme(TransformLexeme.SKEWX, RegExp.$1);\n                buffer = buffer.substr(RegExp.$1.length);\n            }\n            else if (buffer.match(/^(skewY)\\b/)) {\n                result = new TransformLexeme(TransformLexeme.SKEWY, RegExp.$1);\n                buffer = buffer.substr(RegExp.$1.length);\n            }\n            else if (buffer.match(/^(\\()/)) {\n                result = new TransformLexeme(TransformLexeme.LPAREN, RegExp.$1);\n                buffer = buffer.substr(RegExp.$1.length);\n            }\n            else if (buffer.match(/^(\\))/)) {\n                result = new TransformLexeme(TransformLexeme.RPAREN, RegExp.$1);\n                buffer = buffer.substr(RegExp.$1.length);\n            }\n            /* eslint-disable-next-line unicorn/no-unsafe-regex */\n            else if (buffer.match(/^(([-+]?\\d+(\\.\\d*)?|[-+]?\\.\\d+)([eE][-+]?\\d+)?)/)) {\n                result = new TransformLexeme(TransformLexeme.NUMBER, parseFloat(RegExp.$1));\n                buffer = buffer.substr(RegExp.$1.length);\n            }\n            else {\n                throw new Error(\"TransformLexer.getNextToken: unable to tokenize text: \" + buffer);\n            }\n        }\n\n        this._transformText = buffer;\n\n        return result;\n    }\n}\n\nexport default TransformLexer;\n","/**\n *  TransformParser.js\n *\n *  @copyright 2005, 2013 Kevin Lindsey\n */\n\nimport TransformLexer from \"./TransformLexer.js\";\nimport TransformLexeme from \"./TransformLexeme.js\";\n\n\n/**\n *  TransformParser\n */\nclass TransformParser {\n    constructor() {\n        this._lexer = new TransformLexer();\n        this._handler = null;\n    }\n\n    /**\n     *  parseTransform\n     *\n     *  @param {string} transformText\n     */\n    parseTransform(transformText) {\n        if (typeof transformText !== \"string\") {\n            throw new Error(\"TransformParser.parseTransform: The first parameter must be a string\");\n        }\n\n        // init handler\n        if (this._handler !== null && typeof this._handler.beginParse === \"function\") {\n            this._handler.beginParse();\n        }\n\n        // pass the transformText to the lexer\n        const lexer = this._lexer;\n\n        lexer.setTransformText(transformText);\n\n        // Process all tokens\n        let token = lexer.getNextToken();\n\n        while (token.typeis(TransformLexeme.EOD) === false) {\n            let command;\n            let paramCounts;\n            const params = [];\n\n            // process current token\n            switch (token.type) {\n                case TransformLexeme.MATRIX:\n                case TransformLexeme.TRANSLATE:\n                case TransformLexeme.SCALE:\n                case TransformLexeme.ROTATE:\n                case TransformLexeme.SKEWX:\n                case TransformLexeme.SKEWY:\n                    command = token.text;\n                    paramCounts = TransformParser.PARAMCOUNT[command];\n\n                    // Advance past command token\n                    token = lexer.getNextToken();\n                    break;\n\n                default:\n                    throw new Error(\"TransformParser.parseTransform: expected transform type: \" + token.text);\n            }\n\n            // handle opening parenthesis\n            if (token.type !== TransformLexeme.LPAREN) {\n                throw new Error(\"TransformParser.parserTransform: expected opening parenthesis: \" + token.text);\n            }\n            token = lexer.getNextToken();\n\n            // Get parameters\n            while (token !== TransformLexeme.EOD && token.type === TransformLexeme.NUMBER) {\n                // convert current parameter to a float and add to\n                // parameter list\n                params.push(token.text - 0);\n\n                // advance to next token\n                token = lexer.getNextToken();\n            }\n\n            // verify parameter counts\n            let valid = false;\n            const actualCount = params.length;\n\n            for (let i = 0; i < paramCounts.length; i++) {\n                if (paramCounts[i] === actualCount) {\n                    valid = true;\n                    break;\n                }\n            }\n\n            if (valid === false) {\n                throw new Error(\"TransformParser.parserTransform: incorrect number of arguments for \" + command);\n            }\n\n            // handle closing parenthesis\n            if (token.type !== TransformLexeme.RPAREN) {\n                throw new Error(\"TransformParser.parserTransform: expected closing parenthesis: \" + token.text);\n            }\n            token = lexer.getNextToken();\n\n            // fire handler\n            if (this._handler !== null) {\n                const handler = this._handler;\n                const methodName = TransformParser.METHODNAME[command];\n\n                if (handler !== null && typeof handler[methodName] === \"function\") {\n                    handler[methodName](...params);\n                }\n            }\n        }\n    }\n\n    /**\n     *  setHandler\n     *\n     *  @param {Function} handler\n     */\n    setHandler(handler) {\n        this._handler = handler;\n    }\n}\n\n/*\n *  class constants\n */\nTransformParser.PARAMCOUNT = {\n    matrix: [6],\n    translate: [1, 2],\n    scale: [1, 2],\n    rotate: [1, 3],\n    skewX: [1],\n    skewY: [1]\n};\nTransformParser.METHODNAME = {\n    matrix: \"matrix\",\n    translate: \"translate\",\n    scale: \"scale\",\n    rotate: \"rotate\",\n    skewX: \"skewX\",\n    skewY: \"skewY\"\n};\n\nexport default TransformParser;\n","/* eslint-disable prefer-rest-params, class-methods-use-this */\n/**\n *  SampleHandler.js\n *\n *  @copyright 2005, 2013 Kevin Lindsey\n */\n\n/**\n *  show\n *\n *  @param {string} name\n *  @param {Array<string>} params\n */\nfunction show(name, ...params) {\n    console.log(`${name}(${params.join(\",\")})`);\n}\n\n/**\n *  SampleHandler\n */\nclass SampleHandler {\n    /**\n     *  matrix\n     *\n     *  @param {number} a\n     *  @param {number} b\n     *  @param {number} c\n     *  @param {number} d\n     *  @param {number} e\n     *  @param {number} f\n     */\n    matrix(a, b, c, d, e, f) {\n        show(\"matrix\", ...arguments);\n    }\n\n    /**\n     *  translate\n     *\n     *  @param {number} tx\n     *  @param {number} ty\n     */\n    translate(tx, ty) {\n        show(\"translate\", ...arguments);\n    }\n\n    /**\n     *  scale\n     *\n     *  @param {number} sx\n     *  @param {number} sy\n     */\n    scale(sx, sy) {\n        show(\"scale\", ...arguments);\n    }\n\n    /**\n     *  rotate\n     *\n     *  @param {number} rotateAngle\n     *  @param {number} cx\n     *  @param {number} cy\n     */\n    rotate(rotateAngle, cx, cy) {\n        show(\"rotate\", ...arguments);\n    }\n\n    /**\n     *  skewX\n     *\n     *  @param {number} skewAngle\n     */\n    skewX(skewAngle) {\n        show(\"skewX\", ...arguments);\n    }\n\n    /**\n     *  skewY\n     *\n     *  @param {number} skewAngle\n     */\n    skewY(skewAngle) {\n        show(\"skewY\", ...arguments);\n    }\n}\n\nexport default SampleHandler;\n"],"names":["TransformLexeme","type","text","this","UNDEFINED","MATRIX","TRANSLATE","SCALE","ROTATE","SKEWX","SKEWY","LPAREN","RPAREN","NUMBER","EOD","TransformLexer","transformText","setTransformText","Error","_transformText","result","buffer","match","substr","RegExp","$1","length","parseFloat","TransformParser","_lexer","_handler","beginParse","lexer","token","getNextToken","typeis","command","paramCounts","params","PARAMCOUNT","push","valid","actualCount","i","handler","methodName","METHODNAME","show","name","console","log","join","matrix","translate","scale","rotate","skewX","skewY","SampleHandler","a","b","c","d","e","f","arguments","tx","ty","sx","sy","rotateAngle","cx","cy","skewAngle"],"mappings":"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"}